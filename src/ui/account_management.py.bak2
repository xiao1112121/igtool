import os
import sys
import time
import random
import json
import threading
import queue
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
import traceback
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                            QLabel, QLineEdit, QTextEdit, QFileDialog, QMessageBox,
                            QProgressBar, QComboBox, QCheckBox, QSpinBox, QGroupBox,
                            QScrollArea, QFrame, QSplitter, QTabWidget, QApplication,
                            QTableWidget, QTableWidgetItem, QAbstractItemView, QHeaderView, QSizePolicy, QStyledItemDelegate, QMenu, QProgressDialog, QInputDialog)
from PySide6.QtCore import Qt, QThread, Signal, QTimer, QSize, QModelIndex, QRect, QEvent
from PySide6.QtGui import QFont, QIcon, QPixmap, QColor, QPalette, QPainter, QPen, QGuiApplication, QAction
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from webdriver_manager.chrome import ChromeDriverManager
from seleniumwire import webdriver as wire_webdriver
from seleniumwire.utils import decode
from twocaptcha import TwoCaptcha
from src.utils.captcha_handler import CaptchaHandler
from src.ui.utils import random_delay, wait_for_element, wait_for_element_clickable, retry_operation
from src.ui.context_menus import AccountContextMenu
from concurrent.futures import ThreadPoolExecutor, as_completed

class CheckboxDelegate(QStyledItemDelegate):
    CheckboxStateRole = Qt.UserRole + 1
    checkbox_clicked = Signal(int, bool)

    def paint(self, painter: QPainter, option, index: QModelIndex):
        super().paint(painter, option, index)
        check_state_data = index.data(self.CheckboxStateRole)
        is_checked = bool(check_state_data)

        checkbox_size = 15
        rect = option.rect
        x = rect.x() + (rect.width() - checkbox_size) // 2
        y = rect.y() + (rect.height() - checkbox_size) // 2
        checkbox_rect = QRect(x, y, checkbox_size, checkbox_size)

        painter.save()
        painter.setRenderHint(QPainter.Antialiasing)

        if is_checked:
            painter.setBrush(QColor("#1976D2"))
            painter.setPen(QColor("#1976D2"))
        else:
            painter.setBrush(Qt.white)
            painter.setPen(QColor("#CCCCCC"))
        
        painter.drawRoundedRect(checkbox_rect, 2, 2)

        if is_checked:
            painter.setPen(QPen(Qt.white, 2))
            painter.drawLine(x + 3, y + 7, x + 6, y + 10)
            painter.drawLine(x + 6, y + 10, x + 12, y + 4)
            
        painter.restore()

    def editorEvent(self, event, model, option, index: QModelIndex):
        if event.type() == QEvent.MouseButtonPress and event.button() == Qt.LeftButton:
            current_state = index.data(self.CheckboxStateRole)
            new_state = not bool(current_state)
            
            model.setData(index, new_state, self.CheckboxStateRole)
            
            self.checkbox_clicked.emit(index.row(), new_state)
            return True
        return False

class CheckableHeaderView(QHeaderView):
    toggleAllCheckboxes = Signal(bool)

    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)
        self._checked = False
        self.setSectionsClickable(True)

    def paintSection(self, painter, rect, logicalIndex):
        if logicalIndex == 0:
            checkbox_size = 15
            x = rect.x() + (rect.width() - checkbox_size) // 2
            y = rect.y() + (rect.height() - checkbox_size) // 2
            checkbox_rect = QRect(x, y, checkbox_size, checkbox_size)

            painter.save()
            painter.setRenderHint(QPainter.Antialiasing)

            if self._checked:
                painter.setBrush(QColor("#1976D2"))
                painter.setPen(QColor("#1976D2"))
            else:
                painter.setBrush(Qt.white)
                painter.setPen(QColor("#CCCCCC"))
            
            painter.drawRoundedRect(checkbox_rect, 2, 2)

            if self._checked:
                painter.setPen(QPen(Qt.white, 2))
                painter.drawLine(x + 3, y + 7, x + 6, y + 10)
                painter.drawLine(x + 6, y + 10, x + 12, y + 4)
                
            painter.restore()
        else:
            super().paintSection(painter, rect, logicalIndex)

    def mousePressEvent(self, event):
        if self.logicalIndexAt(event.pos()) == 0 and event.button() == Qt.LeftButton:
            self._checked = not self._checked
            self.toggleAllCheckboxes.emit(self._checked)
            self.viewport().update()
            event.accept()
        else:
            super().mousePressEvent(event)


class AccountManagementTab(QWidget):
    proxy_updated = Signal()

    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36"
    ]

    LANGUAGES = [
        "en-US,en;q=0.9",
        "vi-VN,vi;q=0.9,en-US;q=0.8,en;q=0.7",
        "fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7",
        "de-DE,de;q=0.9,en-US;q=0.8,en;q=0.7",
        "ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7"
    ]

    PROXY_USAGE_THRESHOLD = 5
    RECAPTCHA_RETRY_COUNT = 3
    RECAPTCHA_WAIT_TIME = 10

    def __init__(self, proxy_tab_instance=None, parent=None):
        super().__init__(parent)
        self.proxy_tab = proxy_tab_instance
        self.accounts_file = "accounts.json"
        self.folder_map_file = "folder_map.json"
        self.accounts = self.load_accounts()
        self.folder_map = self.load_folder_map()
        self.active_drivers = []
        self.stealth_mode_enabled = False
        self.proxies = self.load_proxies()
        self.init_ui()
        self.update_account_table()
        self.captcha_handler = CaptchaHandler('b452b70e7afcd461cbd3758dac95b3c0')

    def init_driver(self, proxy=None):
        print("[DEBUG] B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o driver...")
        options = Options()
        
        random_user_agent = random.choice(self.USER_AGENTS)
        options.add_argument(f"user-agent={random_user_agent}")
        print(f"[DEBUG] S·ª≠ d·ª•ng User-Agent: {random_user_agent}")

        random_language = random.choice(self.LANGUAGES)
        options.add_argument(f"--lang={random_language}")
        options.add_argument(f"--accept-lang={random_language}")
        print(f"[DEBUG] S·ª≠ d·ª•ng Ng√¥n ng·ªØ: {random_language}")

        if self.stealth_mode_enabled:
            options.add_argument("--incognito")
            print("[DEBUG] Ch·∫ø ƒë·ªô ·∫©n danh ƒë∆∞·ª£c b·∫≠t.")

        proxy_options = {}
        if proxy: 
            print(f"[DEBUG] Proxy ƒë∆∞·ª£c cung c·∫•p: {proxy}")
            proxy_parts = proxy.split(':')
            if len(proxy_parts) == 4:
                proxy_ip_port = f"{proxy_parts[0]}:{proxy_parts[1]}"
                proxy_user = proxy_parts[2]
                proxy_pass = proxy_parts[3]
                
                proxy_options = {
                    'proxy': {
                        'http': f'http://{proxy_user}:{proxy_pass}@{proxy_ip_port}',
                        'https': f'https://{proxy_user}:{proxy_pass}@{proxy_ip_port}',
                        'no_proxy': 'localhost,127.0.0.1' 
                    }
                }
                print(f"[DEBUG] S·ª≠ d·ª•ng proxy c√≥ x√°c th·ª±c v·ªõi selenium-wire: {proxy_ip_port}")
            elif len(proxy_parts) == 2:
                proxy_ip_port = f"{proxy_parts[0]}:{proxy_parts[1]}"
                proxy_options = {
                    'proxy': {
                        'http': f'http://{proxy_ip_port}',
                        'https': f'https://{proxy_ip_port}'
                    }
                }
                print(f"[DEBUG] S·ª≠ d·ª•ng proxy kh√¥ng x√°c th·ª±c v·ªõi selenium-wire: {proxy_ip_port}")
            else:
                print(f"[WARN] ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá, b·ªè qua: {proxy}")
                proxy = None
        else:
            print("[DEBUG] Kh√¥ng c√≥ proxy ƒë∆∞·ª£c cung c·∫•p")
        
        print("[DEBUG] ƒêang kh·ªüi t·∫°o Chrome driver...")
        try:
            driver = wire_webdriver.Chrome(seleniumwire_options=proxy_options, options=options)
            print("[DEBUG] Chrome driver ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o th√†nh c√¥ng")
            return driver
        except Exception as e:
            print(f"[ERROR] L·ªói khi kh·ªüi t·∫°o Chrome driver: {str(e)}")
            raise

    def handle_recaptcha(self, driver, username):
        try:
            recaptcha_frame = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "iframe[src*='recaptcha']"))
            )
            print(f"[DEBUG] Ph√°t hi·ªán reCAPTCHA cho t√†i kho·∫£n {username}")

            driver.switch_to.frame(recaptcha_frame)

            site_key = driver.find_element(By.CLASS_NAME, "g-recaptcha").get_attribute("data-sitekey")
            print(f"[DEBUG] Site key c·ªßa reCAPTCHA: {site_key}")

            driver.switch_to.default_content()

            solver = TwoCaptcha('b452b70e7afcd461cbd3758dac95b3c0')
            try:
                result = solver.recaptcha(
                    sitekey=site_key,
                    url=driver.current_url,
                )
                print(f"[DEBUG] ƒê√£ nh·∫≠n k·∫øt qu·∫£ t·ª´ 2captcha cho {username}")

                driver.execute_script(
                    f'document.getElementById("g-recaptcha-response").innerHTML="{result["code"]}";'
                )
                print(f"[DEBUG] ƒê√£ ƒëi·ªÅn k·∫øt qu·∫£ reCAPTCHA cho {username}")

                submit_button = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']"))
                )
                submit_button.click()
                print(f"[DEBUG] ƒê√£ submit form sau khi gi·∫£i reCAPTCHA cho {username}")

                time.sleep(3)
                return True

            except Exception as e:
                print(f"[ERROR] L·ªói khi gi·∫£i reCAPTCHA cho {username}: {e}")
                return False

        except TimeoutException:
            print(f"[DEBUG] Kh√¥ng t√¨m th·∫•y reCAPTCHA cho {username}")
            return True
        except Exception as e:
            print(f"[ERROR] L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω reCAPTCHA cho {username}: {e}")
            return False
        
    def init_ui(self):
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        sidebar_widget = QWidget()
        self.sidebar_layout = QVBoxLayout(sidebar_widget)
        self.sidebar_layout.setContentsMargins(10, 10, 10, 10)
        self.sidebar_layout.setSpacing(10)

        btn_add_account = QPushButton("Th√™m t√†i kho·∫£n")
        btn_add_account.clicked.connect(self.add_account)
        self.sidebar_layout.addWidget(btn_add_account)

        btn_import_accounts = QPushButton("Import .txt/.csv")
        btn_import_accounts.clicked.connect(self.import_accounts)
        self.sidebar_layout.addWidget(btn_import_accounts)

        btn_add_folder = QPushButton("Th√™m th∆∞ m·ª•c")
        btn_add_folder.clicked.connect(self.open_folder_manager)
        self.sidebar_layout.addWidget(btn_add_folder)

        self.sidebar_layout.addStretch()

        main_layout.addWidget(sidebar_widget, stretch=15)
        
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(0)

        toolbar_frame = QFrame()
        toolbar_frame.setStyleSheet("QFrame { padding-top: 6px; padding-bottom: 6px; }\n")
        toolbar_layout = QHBoxLayout(toolbar_frame)
        toolbar_layout.setSpacing(8)
        toolbar_layout.setContentsMargins(0, 0, 0, 0)

        self.category_combo = QComboBox()
        self.category_combo.addItem("T·∫•t c·∫£")
        self.load_folder_list_to_combo()
        self.category_combo.currentIndexChanged.connect(self.on_folder_changed)
        self.category_combo.setFixedSize(200, 35)
        toolbar_layout.addWidget(self.category_combo)

        btn_load = QPushButton("LOAD")
        btn_load.setFixedSize(80, 35)
        btn_load.setProperty("role", "main")
        btn_load.setProperty("color", "yellow")
        btn_load.clicked.connect(self.load_accounts)
        toolbar_layout.addWidget(btn_load)

        stats_layout = QHBoxLayout()
        stats_layout.setSpacing(8)
        
        self.total_accounts_label = QLabel("T·ªïng: 0")
        self.total_accounts_label.setStyleSheet("color: #333333; font-weight: semibold; font-size: 10.5pt;")
        stats_layout.addWidget(self.total_accounts_label)
        
        self.live_accounts_label = QLabel("Live: 0")
        self.live_accounts_label.setStyleSheet("color: #4CAF50; font-weight: semibold; font-size: 10.5pt;")
        stats_layout.addWidget(self.live_accounts_label)
        
        self.die_accounts_label = QLabel("Die: 0")
        self.die_accounts_label.setStyleSheet("color: #D32F2F; font-weight: semibold; font-size: 10.5pt;")
        stats_layout.addWidget(self.die_accounts_label)
        
        toolbar_layout.addLayout(stats_layout)

        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("T√¨m ki·∫øm t√†i kho·∫£n...")
        self.search_input.textChanged.connect(self.filter_accounts)
        self.search_input.setFixedWidth(150)
        self.search_input.setFixedHeight(35)
        toolbar_layout.addWidget(self.search_input)

        button_layout = QHBoxLayout()
        button_layout.setSpacing(8)

        btn_search = QPushButton("üîç")
        btn_search.clicked.connect(lambda: self.filter_accounts(self.search_input.text()))
        btn_search.setFixedSize(50, 35)
        btn_search.setProperty("role", "main")
        btn_search.setProperty("color", "blue")
        button_layout.addWidget(btn_search)
        
        toolbar_layout.addLayout(button_layout)
        
        right_layout.addWidget(toolbar_frame)

        self.account_table = QTableWidget()
        self.account_table.setColumnCount(10)
        self.account_table.setHorizontalHeaderLabels([
            "", "STT", "T√™n ƒëƒÉng nh·∫≠p", "M·∫≠t kh·∫©u", "Tr·∫°ng th√°i", 
            "Proxy", "Tr·∫°ng th√°i Proxy", "Follower", "Following", "H√†nh ƒë·ªông cu·ªëi"
        ])
        
        self.checkbox_delegate = CheckboxDelegate(self)
        self.account_table.setItemDelegateForColumn(0, self.checkbox_delegate)
        self.checkbox_delegate.checkbox_clicked.connect(self.on_checkbox_clicked)

        self.header_checkbox = CheckableHeaderView(Qt.Horizontal, self.account_table)
        self.account_table.setHorizontalHeader(self.header_checkbox)
        header = self.header_checkbox

        header.setSectionResizeMode(0, QHeaderView.Fixed)
        self.account_table.setColumnWidth(0, 29)
        header.setSectionResizeMode(1, QHeaderView.Fixed)
        self.account_table.setColumnWidth(1, 29)
        header.setSectionResizeMode(2, QHeaderView.Fixed)
        self.account_table.setColumnWidth(2, 150)
        header.setSectionResizeMode(3, QHeaderView.Fixed)
        self.account_table.setColumnWidth(3, 150)
        header.setSectionResizeMode(4, QHeaderView.Fixed)
        self.account_table.setColumnWidth(4, 120)
        header.setSectionResizeMode(5, QHeaderView.Fixed)
        self.account_table.setColumnWidth(5, 200)
        header.setSectionResizeMode(6, QHeaderView.Fixed)
        self.account_table.setColumnWidth(6, 150)
        header.setSectionResizeMode(7, QHeaderView.Fixed)
        self.account_table.setColumnWidth(7, 79)
        header.setSectionResizeMode(8, QHeaderView.Fixed)
        self.account_table.setColumnWidth(8, 79)
        header.setSectionResizeMode(9, QHeaderView.Stretch)
        self.account_table.verticalHeader().setDefaultSectionSize(29)

        header.setStretchLastSection(True)

        self.account_table.horizontalHeader().setDefaultAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

        self.account_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.account_table.setEditTriggers(QTableWidget.NoEditTriggers)
        self.account_table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.account_table.customContextMenuRequested.connect(self.show_context_menu)
        self.account_table.itemChanged.connect(self.handle_item_changed)
        self.account_table.verticalHeader().setVisible(False)
        self.account_table.itemDoubleClicked.connect(self.on_table_item_double_clicked)

        right_layout.addWidget(self.account_table)
        main_layout.addWidget(right_panel, stretch=85)

        self.header_checkbox.toggleAllCheckboxes.connect(self.toggle_all_accounts_selection)

    def load_accounts(self):
        if os.path.exists(self.accounts_file):
            try:
                with open(self.accounts_file, 'r', encoding='utf-8') as f:
                    accounts_data = json.load(f)
                    for account in accounts_data:
                        if "proxy_status" not in account:
                            account["proxy_status"] = "Ch∆∞a ki·ªÉm tra"
                    return accounts_data
            except json.JSONDecodeError:
                print("[ERROR] L·ªói ƒë·ªçc file accounts.json. File c√≥ th·ªÉ b·ªã h·ªèng.")
                return []
        return []

    def save_accounts(self):
        with open(self.accounts_file, 'w', encoding='utf-8') as f:
            json.dump(self.accounts, f, indent=4, ensure_ascii=False)
        print("[INFO] T√†i kho·∫£n ƒë√£ ƒë∆∞·ª£c l∆∞u.")

    def save_folder_map(self):
        with open(self.folder_map_file, 'w', encoding='utf-8') as f:
            json.dump(self.folder_map, f, indent=4, ensure_ascii=False)
        print("[INFO] B·∫£n ƒë·ªì th∆∞ m·ª•c ƒë√£ ƒë∆∞·ª£c l∆∞u.")

    def add_account(self):
        username, ok = QInputDialog.getText(self, "Th√™m t√†i kho·∫£n", "T√™n ng∆∞·ªùi d√πng:")
        if ok and username:
            password, ok = QInputDialog.getText(self, "Th√™m t√†i kho·∫£n", "M·∫≠t kh·∫©u:", QLineEdit.Password)
            if ok:
                proxy, ok = QInputDialog.getText(self, "Th√™m t√†i kho·∫£n", "Proxy (t√πy ch·ªçn):")
                if ok:
                    new_account = {
                        "selected": False,
                        "username": username,
                        "password": password,
                        "fullname": "",
                        "proxy": proxy,
                        "status": "Ch∆∞a ƒëƒÉng nh·∫≠p",
                        "gender": "-",
                        "followers": "",
                        "following": "",
                        "last_action": "",
                        "proxy_status": "Ch∆∞a ki·ªÉm tra"
                    }
                    self.accounts.append(new_account)
                    self.save_accounts()
                    self.update_account_table()
                    QMessageBox.information(self, "Th√™m t√†i kho·∫£n", "T√†i kho·∫£n ƒë√£ ƒë∆∞·ª£c th√™m th√†nh c√¥ng.")

    def update_account_table(self, accounts_to_display=None):
        if accounts_to_display is None:
            accounts_to_display = self.accounts

        total_count = len(accounts_to_display)
        live_count = sum(1 for acc in accounts_to_display if acc.get("status") == "Live" or acc.get("status") == "ƒê√£ ƒëƒÉng nh·∫≠p")
        die_count = sum(1 for acc in accounts_to_display if acc.get("status") == "Die")

        self.total_accounts_label.setText(f"T·ªïng: {total_count}")
        self.live_accounts_label.setText(f"Live: {live_count}")
        self.die_accounts_label.setText(f"Die: {die_count}")

        self.account_table.blockSignals(True)
        self.account_table.setRowCount(len(accounts_to_display))
        for row_idx, account in enumerate(accounts_to_display):
            item_checkbox = QTableWidgetItem()
            item_checkbox.setFlags(Qt.ItemIsEnabled | Qt.ItemIsUserCheckable | Qt.ItemIsSelectable)
            item_checkbox.setData(CheckboxDelegate.CheckboxStateRole, account.get("selected", False))
            self.account_table.setItem(row_idx, 0, item_checkbox)

            stt_item = QTableWidgetItem(str(row_idx + 1))
            stt_item.setTextAlignment(Qt.AlignCenter)
            self.account_table.setItem(row_idx, 1, stt_item)

            username_item = QTableWidgetItem(account.get("username", ""))
            username_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self.account_table.setItem(row_idx, 2, username_item)

            password_item = QTableWidgetItem(account.get("password", ""))
            password_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self.account_table.setItem(row_idx, 3, password_item)

            status_item = QTableWidgetItem(account.get("status", "Ch∆∞a ƒëƒÉng nh·∫≠p"))
            status_item.setTextAlignment(Qt.AlignCenter)
            if account.get("status") == "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i":
                status_item.setForeground(QColor("red"))
            elif account.get("status") == "ƒê√£ ƒëƒÉng nh·∫≠p" or account.get("status") == "Live":
                status_item.setForeground(QColor("green"))
            elif account.get("status") == "Die":
                status_item.setForeground(QColor("red"))
            else:
                status_item.setForeground(QColor("black"))
            self.account_table.setItem(row_idx, 4, status_item)

            proxy_item = QTableWidgetItem(account.get("proxy", ""))
            proxy_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self.account_table.setItem(row_idx, 5, proxy_item)

            proxy_status_item = QTableWidgetItem(account.get("proxy_status", "Ch∆∞a ki·ªÉm tra"))
            proxy_status_item.setTextAlignment(Qt.AlignCenter)
            if account.get("proxy_status") == "Die":
                proxy_status_item.setForeground(QColor("red"))
            elif account.get("proxy_status") == "OK":
                proxy_status_item.setForeground(QColor("green"))
            else:
                proxy_status_item.setForeground(QColor("black"))
            self.account_table.setItem(row_idx, 6, proxy_status_item)

            follower_item = QTableWidgetItem(account.get("followers", ""))
            follower_item.setTextAlignment(Qt.AlignCenter)
            self.account_table.setItem(row_idx, 7, follower_item)

            following_item = QTableWidgetItem(account.get("following", ""))
            following_item.setTextAlignment(Qt.AlignCenter)
            self.account_table.setItem(row_idx, 8, following_item)

            last_action_item = QTableWidgetItem(account.get("last_action", ""))
            last_action_item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            self.account_table.setItem(row_idx, 9, last_action_item)
        self.account_table.blockSignals(False)

    def on_checkbox_clicked(self, row, new_state):
        if row < len(self.accounts):
            self.accounts[row]["selected"] = new_state
            self.save_accounts()
            print(f"[DEBUG] Checkbox t·∫°i h√†ng {row} ƒë∆∞·ª£c chuy·ªÉn th√†nh: {new_state}. T√†i kho·∫£n: {self.accounts[row]['username']}")

    def handle_item_changed(self, item):
        if self.account_table.signalsBlocked():
            return

        row = item.row()
        col = item.column()

        if col == 0:
            return

        if col == 2:
            self.accounts[row]["username"] = item.text()
        elif col == 3:
            self.accounts[row]["password"] = item.text()
        elif col == 5:
            self.accounts[row]["proxy"] = item.text()
        else:
            return

        self.save_accounts()

    def filter_accounts(self, text):
        filtered_accounts = [
            account for account in self.accounts
            if text.lower() in account.get("username", "").lower() or
               text.lower() in account.get("status", "").lower() or
               text.lower() in account.get("proxy", "").lower() or
               text.lower() in account.get("proxy_status", "").lower() or
               text.lower() in account.get("last_action", "").lower()
        ]
        if self.category_combo.currentText() != "T·∫•t c·∫£":
            folder_name = self.category_combo.currentText()
            filtered_accounts = [acc for acc in filtered_accounts if self.folder_map.get(acc.get("username"), "T·ªïng") == folder_name]
        
        self.update_account_table(filtered_accounts)

    def get_window_positions(self, num_windows):
        screen = QGuiApplication.primaryScreen().geometry()
        screen_width = screen.width()
        screen_height = screen.height()

        window_width = 448
        window_height = 415
        
        positions = []

        max_cols = screen_width // window_width
        max_rows = screen_height // window_height

        if max_cols == 0 or max_rows == 0:
            print("[WARN] M√†n h√¨nh qu√° nh·ªè ƒë·ªÉ hi·ªÉn th·ªã c·ª≠a s·ªï theo k√≠ch th∆∞·ªõc mong mu·ªën. Vui l√≤ng tƒÉng ƒë·ªô ph√¢n gi·∫£i m√†n h√¨nh ho·∫∑c gi·∫£m s·ªë l∆∞·ª£ng c·ª≠a s·ªï.")
            return [(0, 0, window_width, window_height)]

        cols = max_cols
        rows = (num_windows + cols - 1) // cols

        for i in range(num_windows):
            row = i // cols
            col = i % cols

            x = col * window_width
            y = row * window_height

            if x + window_width > screen_width:
                x = screen_width - window_width
            if y + window_height > screen_height:
                y = screen_height - window_height
            
            x = max(0, x)
            y = max(0, y)

            positions.append((x, y, window_width, window_height))
        return positions

    def login_selected_accounts(self):
        selected_accounts = [acc for acc in self.accounts if acc.get("selected")]
        if not selected_accounts:
            QMessageBox.warning(self, "ƒêƒÉng nh·∫≠p t√†i kho·∫£n", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t√†i kho·∫£n ƒë·ªÉ ƒëƒÉng nh·∫≠p.")
            return

        num_accounts_to_login = len(selected_accounts)
        window_positions = self.get_window_positions(num_accounts_to_login)

        max_workers = min(5, num_accounts_to_login)
        print(f"[DEBUG] ƒêang ƒëƒÉng nh·∫≠p {num_accounts_to_login} t√†i kho·∫£n v·ªõi {max_workers} tr√¨nh duy·ªát ƒë·ªìng th·ªùi.")

        self.progress_dialog = QProgressDialog("ƒêang ƒëƒÉng nh·∫≠p t√†i kho·∫£n...", "H·ªßy", 0, num_accounts_to_login, self)
        self.progress_dialog.setWindowTitle("Ti·∫øn tr√¨nh ƒëƒÉng nh·∫≠p")
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.canceled.connect(self.close_all_drivers)
        self.progress_dialog.show()

        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_account = {
                executor.submit(self.login_instagram_and_get_info, account, window_positions[i]): account
                for i, account in enumerate(selected_accounts)
            }
            completed_count = 0
            for future in as_completed(future_to_account):
                account = future_to_account[future]
                try:
                    result = future.result()
                    print(f"[DEBUG] K·∫øt qu·∫£ t·ª´ login_instagram_and_get_info cho {account.get('username', 'N/A')}: {result} (Ki·ªÉu: {type(result)}) (ƒê·ªô d√†i: {len(result) if isinstance(result, tuple) else 'N/A'})")
                    
                    if result is None:
                        print(f"[ERROR] login_instagram_and_get_info tr·∫£ v·ªÅ None cho {account.get('username', 'N/A')}.")
                        login_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh (None)"
                        proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                    elif isinstance(result, tuple) and len(result) == 2:
                        login_status, proxy_status = result
                        account["status"] = login_status
                        account["proxy_status"] = proxy_status
                        if login_status == "ƒê√£ ƒëƒÉng nh·∫≠p":
                            self.save_accounts()
                    else:
                        print(f"[ERROR] K·∫øt qu·∫£ tr·∫£ v·ªÅ kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng cho {account.get('username', 'N/A')}. Expected (status, proxy_status), got: {result}")
                        login_status = "L·ªói d·ªØ li·ªáu tr·∫£ v·ªÅ"
                        proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"

                    account["status"] = login_status
                    account["proxy_status"] = proxy_status

                except Exception as e:
                    account["status"] = f"L·ªói: {type(e).__name__}"
                    account["proxy_status"] = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                    print(f"[ERROR] T√†i kho·∫£n {account.get('username', 'N/A')} t·∫°o ra m·ªôt ngo·∫°i l·ªá: {e}")
                    traceback.print_exc()
                finally:
                    completed_count += 1
                    self.progress_dialog.setValue(completed_count)
                    self.update_account_table()

            self.progress_dialog.close()
            self.update_account_table()

    def login_instagram_and_get_info(self, account, window_position=None, max_retries=3, retry_delay=5):
        driver = None
        username = account.get("username")
        password = account.get("password")
        proxy = account.get("proxy")

        def _perform_login():
            nonlocal driver
            nonlocal proxy
            login_status = "Th·∫•t b·∫°i"
            proxy_status = "Ch∆∞a ki·ªÉm tra"
            try:
                print(f"[DEBUG] B·∫Øt ƒë·∫ßu ƒëƒÉng nh·∫≠p cho t√†i kho·∫£n {username}")
                if proxy:
                    current_proxy_info = next((p for p in self.proxies if f"{p.get('ip')}:{p.get('port')}:{p.get('user')}:{p.get('pass')}" == proxy), None)
                    if current_proxy_info and current_proxy_info.get("status") == "Die":
                        print(f"[WARN] Proxy {proxy} cho t√†i kho·∫£n {username} ƒëang ·ªü tr·∫°ng th√°i Die, ƒëang c·ªë g·∫Øng g√°n proxy m·ªõi.")
                        self._assign_new_proxy(account)
                        proxy = account.get("proxy")
                        if not proxy:
                            proxy_status = "Kh√¥ng c√≥ proxy kh·∫£ d·ª•ng"
                            return "L·ªói Proxy", proxy_status
                elif proxy == "":
                    print(f"[DEBUG] T√†i kho·∫£n {username} kh√¥ng s·ª≠ d·ª•ng proxy.")
                    proxy = None
                elif proxy is None and self.proxies:
                    print(f"[DEBUG] T√†i kho·∫£n {username} ch∆∞a c√≥ proxy, ƒëang c·ªë g·∫Øng g√°n proxy m·ªõi t·ª´ danh s√°ch.")
                    self._assign_new_proxy(account)
                    proxy = account.get("proxy")
                    if not proxy:
                        proxy_status = "Kh√¥ng c√≥ proxy kh·∫£ d·ª•ng"
                        return "L·ªói Proxy", proxy_status
                elif proxy is None and not self.proxies:
                    print(f"[DEBUG] T√†i kho·∫£n {username} kh√¥ng s·ª≠ d·ª•ng proxy (ho·∫∑c kh√¥ng c√≥ proxy n√†o ƒë∆∞·ª£c t·∫£i).")
                    proxy = None

                if proxy is None:
                    proxy = None

                driver = self.init_driver(proxy)

                if window_position:
                    x, y, width, height = window_position
                    driver.set_window_rect(x, y, width, height)
                    print(f"[DEBUG] ƒê√£ ƒë·∫∑t v·ªã tr√≠ c·ª≠a s·ªï cho {username} t·∫°i ({x}, {y}, {width}, {height})")
                
                driver.get("https://www.instagram.com/accounts/login/")
                print(f"[DEBUG] ƒê√£ truy c·∫≠p trang ƒëƒÉng nh·∫≠p cho {username}")

                try:
                    accept_cookies_button = wait_for_element_clickable(driver, By.XPATH, "//button[text()='Cho ph√©p t·∫•t c·∫£ cookie'] | //button[text()='Accept All'] | //button[text()='Allow all cookies']", timeout=5)
                    if accept_cookies_button:
                        print(f"[DEBUG] ƒê√£ ch·∫•p nh·∫≠n cookie cho {username}.")
                        random_delay(1, 2)
                except Exception as e:
                    print(f"[DEBUG] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ click n√∫t ch·∫•p nh·∫≠n cookie cho {username}: {e}")
                
                username_input = wait_for_element(driver, By.NAME, "username", timeout=10)
                if not username_input:
                    raise Exception("Kh√¥ng th·ªÉ t√¨m th·∫•y √¥ nh·∫≠p username")
                print(f"[DEBUG] Trang ƒëƒÉng nh·∫≠p ƒë√£ t·∫£i xong cho {username}")
                
                password_input = wait_for_element(driver, By.NAME, "password", timeout=5)
                if not password_input:
                    raise Exception("Kh√¥ng th·ªÉ t√¨m th·∫•y √¥ nh·∫≠p password")
                
                random_delay()
                username_input.send_keys(username)
                
                random_delay()
                password_input.send_keys(password)
                
                random_delay(1, 2)
                login_button = wait_for_element(driver, By.CSS_SELECTOR, "button[type='submit']", timeout=10)
                if not login_button:
                    raise Exception("Kh√¥ng th·ªÉ t√¨m th·∫•y n√∫t ƒëƒÉng nh·∫≠p")
                driver.execute_script("arguments[0].click();", login_button)
                print(f"[DEBUG] ƒê√£ click n√∫t ƒëƒÉng nh·∫≠p cho {username} b·∫±ng JavaScript")

                try:
                    not_now_button_xpath = (
                        "//button[text()='Not Now'] | "
                        "//button[text()='L√∫c kh√°c'] | "
                        "//button[text()='Sp√§ter'] | "
                        "//button[text()='M√°s tarde'] | "
                        "//button[text()='Jetzt nicht'] | "
                        "//button[contains(.,'Not Now')] | "
                        "//button[contains(.,'L√∫c kh√°c')] | "
                        "//div[text()='L∆∞u th√¥ng tin ƒëƒÉng nh·∫≠p?']/ancestor::div[contains(@class, 'x1n2onr6')]//button[contains(.,'L√∫c kh√°c')] | "
                        "//div[text()='Save your login info?']/ancestor::div[contains(@class, 'x1n2onr6')]//button[contains(.,'Not Now')]"
                    )
                    not_now_button = wait_for_element_clickable(driver, By.XPATH, not_now_button_xpath, timeout=7)
                    if not_now_button:
                        print(f"[DEBUG] ƒê√£ click n√∫t 'Not Now' (l∆∞u th√¥ng tin ƒëƒÉng nh·∫≠p) cho {username}.")
                        random_delay(1, 2)
                except Exception as e:
                    print(f"[DEBUG] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ click n√∫t 'Not Now' (l∆∞u th√¥ng tin ƒëƒÉng nh·∫≠p) cho {username}: {e}")

                try:
                    turn_on_notifications_not_now_xpath = (
                        "//button[text()='Not Now'] | "
                        "//button[text()='L√∫c kh√°c'] | "
                        "//button[text()='Sp√§ter'] | "
                        "//button[text()='Ahora no'] | "
                        "//button[contains(.,'Not Now')] | "
                        "//button[contains(.,'L√∫c kh√°c')] | "
                        "//div[text()='Turn on notifications?']/ancestor::div[contains(@class, 'x1n2onr6')]//button[contains(.,'Not Now')] | "
                        "//div[text()='B·∫≠t th√¥ng b√°o?']/ancestor::div[contains(@class, 'x1n2onr6')]//button[contains(.,'L√∫c kh√°c')]"
                    )
                    turn_on_notifications_not_now_button = wait_for_element_clickable(driver, By.XPATH, turn_on_notifications_not_now_xpath, timeout=7)
                    if turn_on_notifications_not_now_button:
                        print(f"[DEBUG] ƒê√£ click n√∫t 'Not Now' (th√¥ng b√°o) cho {username}.")
                        random_delay(1, 2)
                except Exception as e:
                    print(f"[DEBUG] Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ click n√∫t 'Not Now' (th√¥ng b√°o) cho {username}: {e}")

                random_delay(2, 4)
                
                try:
                    recaptcha_frame = WebDriverWait(driver, 5).until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "iframe[src*='recaptcha']"))
                    )
                    print(f"[DEBUG] Ph√°t hi·ªán reCAPTCHA cho t√†i kho·∫£n {username}")

                    if not self.captcha_handler.handle_recaptcha(driver, username):
                        print("[ERROR] Kh√¥ng th·ªÉ gi·∫£i captcha")
                        login_status = "L·ªói Captcha"
                        proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                        return login_status, proxy_status
                    else:
                        print(f"[DEBUG] ƒê√£ x·ª≠ l√Ω reCAPTCHA th√†nh c√¥ng cho t√†i kho·∫£n {username}.")
                        if not wait_for_element(driver, By.NAME, "username"):
                            print("[ERROR] Kh√¥ng th·ªÉ t√¨m th·∫•y √¥ nh·∫≠p username sau khi gi·∫£i captcha")
                            login_status = "Kh√¥ng t√¨m th·∫•y username input sau Captcha"
                            proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                            return login_status, proxy_status

                except TimeoutException:
                    print(f"[DEBUG] Kh√¥ng t√¨m th·∫•y reCAPTCHA cho t√†i kho·∫£n {username}.")
                except Exception as e:
                    print(f"[ERROR] L·ªói kh√¥ng x√°c ƒë·ªãnh khi x·ª≠ l√Ω reCAPTCHA cho {username}: {e}")
                    login_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh Captcha"
                    proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                    return login_status, proxy_status

                print(f"[DEBUG] ƒêang ch·ªù x√°c nh·∫≠n ƒëƒÉng nh·∫≠p th√†nh c√¥ng cho {username}")
                login_success_flag = False
                try:
                    WebDriverWait(driver, 20).until(
                        EC.url_contains("instagram.com") and not EC.url_contains("accounts/login")
                    )
                    print(f"[DEBUG] URL ƒë√£ chuy·ªÉn h∆∞·ªõng sau ƒëƒÉng nh·∫≠p cho {username}.")
                    if wait_for_element(driver, By.CSS_SELECTOR, "svg[aria-label='Home']", timeout=10):
                        login_success_flag = True
                        print(f"[DEBUG] ƒê√£ t√¨m th·∫•y bi·ªÉu t∆∞·ª£ng Home cho {username}.")
                except TimeoutException:
                    print(f"[WARN] Kh√¥ng th·ªÉ x√°c nh·∫≠n chuy·ªÉn h∆∞·ªõng URL ho·∫∑c bi·ªÉu t∆∞·ª£ng Home cho {username} trong th·ªùi gian ch·ªù.")

                if not login_success_flag:
                    print("[ERROR] Kh√¥ng th·ªÉ x√°c nh·∫≠n ƒëƒÉng nh·∫≠p th√†nh c√¥ng")
                    login_status = "Kh√¥ng x√°c nh·∫≠n ƒëƒÉng nh·∫≠p"
                    proxy_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                    return login_status, proxy_status
                print(f"[DEBUG] ƒêƒÉng nh·∫≠p th√†nh c√¥ng cho {username}")
                login_status = "ƒê√£ ƒëƒÉng nh·∫≠p"
                proxy_status = "OK"

                return login_status, proxy_status

            except Exception as e:
                print(f"[ERROR] L·ªói khi ƒëƒÉng nh·∫≠p cho {username}: {e}")
                login_status = "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i"
                proxy_status = "Ch∆∞a ki·ªÉm tra"
                if "element click intercepted" in str(e).lower():
                    login_status = "L·ªói click ch·∫∑n"
                elif "Kh√¥ng th·ªÉ t√¨m th·∫•y √¥ nh·∫≠p username" in str(e):
                    login_status = "Kh√¥ng t√¨m th·∫•y username input"
                elif "Kh√¥ng th·ªÉ x√°c nh·∫≠n ƒëƒÉng nh·∫≠p th√†nh c√¥ng" in str(e):
                    login_status = "Kh√¥ng x√°c nh·∫≠n ƒëƒÉng nh·∫≠p"
                elif "ERR_PROXY_CONNECTION_FAILED" in str(e):
                    proxy_status = "Die"
                    login_status = "L·ªói Proxy"
                else:
                    login_status = "L·ªói kh√¥ng x√°c ƒë·ªãnh"
                return login_status, proxy_status
            finally:
                if driver:
                    driver.quit()
                    print(f"[DEBUG] ƒê√£ ƒë√≥ng tr√¨nh duy·ªát cho {username}")
        
        return retry_operation(_perform_login, max_retries=max_retries, retry_delay=retry_delay)

    def close_all_drivers(self):
        for driver in self.active_drivers:
            try:
                driver.quit()
            except Exception as e:
                print(f"[WARN] L·ªói khi ƒë√≥ng tr√¨nh duy·ªát: {e}")
        self.active_drivers = []
        print("[INFO] ƒê√£ ƒë√≥ng t·∫•t c·∫£ c√°c tr√¨nh duy·ªát.")

    def import_accounts(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Nh·∫≠p t√†i kho·∫£n", "", "JSON Files (*.json)")
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    imported_accounts = json.load(f)
                self.accounts.extend(imported_accounts)
                self.save_accounts()
                self.update_account_table()
                QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ nh·∫≠p t√†i kho·∫£n th√†nh c√¥ng!")
            except Exception as e:
                QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ nh·∫≠p t√†i kho·∫£n: {str(e)}")

    def open_folder_manager(self):
        if not hasattr(self, 'folder_map'):
            self.folder_map = self.load_folder_map()
        from src.ui.folder_manager import FolderManagerDialog
        dialog = FolderManagerDialog(self.accounts, self.folder_map, self)
        dialog.folders_updated.connect(self.on_folders_updated)
        dialog.exec()

    def load_folder_list_to_combo(self):
        self.category_combo.clear()
        self.category_combo.addItem("T·∫•t c·∫£")
        if not hasattr(self, 'folder_map') or not self.folder_map:
            self.folder_map = self.load_folder_map()
        
        unique_folders = sorted(list(set(self.folder_map.values())))
        for folder_name in unique_folders:
            if folder_name != "T·ªïng":
                self.category_combo.addItem(folder_name)
        print(f"[DEBUG] ƒê√£ t·∫£i danh s√°ch th∆∞ m·ª•c v√†o combobox: {list(self.folder_map.keys())}")


    def on_folder_changed(self):
        selected_folder = self.category_combo.currentText()
        if selected_folder == "T·∫•t c·∫£":
            self.update_account_table(self.accounts)
        else:
            filtered_accounts = [acc for acc in self.accounts if self.folder_map.get(acc.get("username"), "T·ªïng") == selected_folder]
            self.update_account_table(filtered_accounts)
        print(f"[DEBUG] ƒê√£ l·ªçc t√†i kho·∫£n theo th∆∞ m·ª•c: {selected_folder}")

    def on_folders_updated(self):
        print("[DEBUG] T√≠n hi·ªáu folders_updated ƒë√£ ƒë∆∞·ª£c nh·∫≠n trong AccountManagementTab.")
        self.save_folder_map()
        self.load_folder_list_to_combo()
        self.update_account_table()


    def show_context_menu(self, pos):
        print(f"[DEBUG] show_context_menu ƒë∆∞·ª£c g·ªçi t·∫°i v·ªã tr√≠: {pos}")
        menu = AccountContextMenu(self)
        menu.exec(self.account_table.viewport().mapToGlobal(pos))

    def on_table_item_double_clicked(self, index):
        selected_account = self.accounts[index.row()]
        QMessageBox.information(self, "Chi ti·∫øt t√†i kho·∫£n", 
                                f"T√™n ƒëƒÉng nh·∫≠p: {selected_account.get('username', 'N/A')}\n"
                                f"M·∫≠t kh·∫©u: {selected_account.get('password', 'N/A')}\n"
                                f"Tr·∫°ng th√°i: {selected_account.get('status', 'N/A')}\n"
                                f"Proxy: {selected_account.get('proxy', 'N/A')}\n"
                                f"Tr·∫°ng th√°i Proxy: {selected_account.get('proxy_status', 'N/A')}\n"
                                f"Follower: {selected_account.get('followers', 'N/A')}\n"
                                f"Following: {selected_account.get('following', 'N/A')}\n"
                                f"H√†nh ƒë·ªông cu·ªëi: {selected_account.get('last_action', 'N/A')}")

    def toggle_all_accounts_selection(self, checked):
        for row_idx in range(self.account_table.rowCount()):
            item = self.account_table.item(row_idx, 0)
            if item:
                self.account_table.model().setData(item.index(), checked, CheckboxDelegate.CheckboxStateRole)
                if row_idx < len(self.accounts):
                    self.accounts[row_idx]["selected"] = checked
                self.save_accounts()

    def load_proxies(self):
        proxies = []
        proxies_file = "proxies.txt"
        if os.path.exists(proxies_file):
            with open(proxies_file, 'r', encoding='utf-8-sig') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        parts = line.split(':')
                        if len(parts) == 4:
                            ip, port, user, password = parts
                            proxies.append({"ip": ip, "port": port, "user": user, "pass": password, "status": "Ch∆∞a ki·ªÉm tra", "is_in_use": False, "usage_count": 0})
                        elif len(parts) == 2:
                            ip, port = parts
                            proxies.append({"ip": ip, "port": port, "user": "", "pass": "", "status": "Ch∆∞a ki·ªÉm tra", "is_in_use": False, "usage_count": 0})
                        else:
                            print(f"[WARN] ƒê·ªãnh d·∫°ng proxy kh√¥ng h·ª£p l·ªá, b·ªè qua: {line}")
        print(f"[DEBUG] ƒê√£ t·∫£i {len(proxies)} proxy.")
        return proxies

    def load_folder_map(self):
        if os.path.exists(self.folder_map_file):
            try:
                with open(self.folder_map_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                print("[ERROR] L·ªói ƒë·ªçc file folder_map.json. File c√≥ th·ªÉ b·ªã h·ªèng. T·∫°o l·∫°i map tr·ªëng.")
                return {}
        return {}

    def _assign_new_proxy(self, account):
        current_proxy = account.get("proxy", "")
        username = account.get("username", "")
        print(f"[DEBUG] ƒêang t√¨m proxy m·ªõi cho t√†i kho·∫£n {username}. Proxy hi·ªán t·∫°i: {current_proxy}")

        new_proxy_info = None

        for proxy_info in self.proxies:
            if (proxy_info.get("status") == "OK" or proxy_info.get("status") == "Ch∆∞a ki·ªÉm tra") and \
               not proxy_info.get("is_in_use", False) and \
               proxy_info.get("usage_count", 0) < self.PROXY_USAGE_THRESHOLD:
                new_proxy_info = proxy_info
                print(f"[DEBUG] ƒê√£ t√¨m th·∫•y proxy ∆∞u ti√™n (th·∫•p s·ª≠ d·ª•ng): {proxy_info.get('ip')}. Usage: {proxy_info.get('usage_count')}")
                break
        
        if not new_proxy_info:
            print("[DEBUG] Kh√¥ng t√¨m th·∫•y proxy ∆∞u ti√™n, ƒëang t√¨m proxy kh·∫£ d·ª•ng b·∫•t k·ª≥.")
            for proxy_info in self.proxies:
                if (proxy_info.get("status") == "OK" or proxy_info.get("status") == "Ch∆∞a ki·ªÉm tra") and \
                   not proxy_info.get("is_in_use", False):
                    new_proxy_info = proxy_info
                    print(f"[DEBUG] ƒê√£ t√¨m th·∫•y proxy kh·∫£ d·ª•ng: {proxy_info.get('ip')}. Usage: {proxy_info.get('usage_count')}")
                    break
        
        if new_proxy_info:
            account["proxy"] = f"{new_proxy_info.get('ip')}:{new_proxy_info.get('port')}:{new_proxy_info.get('user')}:{new_proxy_info.get('pass')}"
            new_proxy_info["is_in_use"] = True
            new_proxy_info["status"] = "ƒêang s·ª≠ d·ª•ng"
            account["proxy_status"] = "ƒêang chuy·ªÉn ƒë·ªïi"
            print(f"[INFO] ƒê√£ g√°n proxy m·ªõi {account['proxy']} cho t√†i kho·∫£n {username}.")
        else:
            account["proxy_status"] = "Kh√¥ng c√≥ proxy kh·∫£ d·ª•ng"
            print(f"[WARN] Kh√¥ng t√¨m th·∫•y proxy kh·∫£ d·ª•ng n√†o cho t√†i kho·∫£n {username}.")
        
        self.save_accounts()

    def _perform_warmup(self, driver, delay_multiplier):
        driver.get("https://www.instagram.com")
        time.sleep(2 * delay_multiplier)
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(2 * delay_multiplier)
        try:
            post_links = driver.find_elements(By.XPATH, "//a[contains(@href, '/p/')]") 
            if post_links:
                random_post = random.choice(post_links)
                random_post.click()
                time.sleep(5 * delay_multiplier)
                driver.back()
                time.sleep(2 * delay_multiplier)
        except Exception as e:
            print(f"[WARN] L·ªói khi th·ª±c hi·ªán warm-up: {e}")
        print("[DEBUG] ƒê√£ ho√†n t·∫•t phi√™n warm-up.")

    def get_info_selected_accounts(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "L·∫•y th√¥ng tin t√†i kho·∫£n ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng get_info_selected_accounts ƒë∆∞·ª£c g·ªçi.")

    def open_browser_for_selected(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "M·ªü tr√¨nh duy·ªát ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng open_browser_for_selected ƒë∆∞·ª£c g·ªçi.")

    def logout_selected_accounts(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "ƒêƒÉng xu·∫•t t√†i kho·∫£n ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng logout_selected_accounts ƒë∆∞·ª£c g·ªçi.")

    def delete_selected_accounts(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "X√≥a t√†i kho·∫£n ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng delete_selected_accounts ƒë∆∞·ª£c g·ªçi.")

    def select_selected_accounts(self):
        selected_rows = self.account_table.selectionModel().selectedRows()
        for index in selected_rows:
            row = index.row()
            if row < len(self.accounts):
                item_checkbox = self.account_table.item(row, 0)
                if item_checkbox and item_checkbox.checkState() == Qt.Unchecked:
                    item_checkbox.setCheckState(Qt.Checked)
                    self.accounts[row]["selected"] = True
        self.save_accounts()
        QMessageBox.information(self, "Ch·ªçn t√†i kho·∫£n", f"ƒê√£ ch·ªçn {len(selected_rows)} t√†i kho·∫£n ƒë∆∞·ª£c b√¥i ƒëen.")
        print(f"[DEBUG] ƒê√£ ch·ªçn {len(selected_rows)} t√†i kho·∫£n ƒë∆∞·ª£c b√¥i ƒëen.")

    def deselect_selected_accounts(self):
        selected_rows = self.account_table.selectionModel().selectedRows()
        deselected_count = 0
        for index in selected_rows:
            row = index.row()
            if row < len(self.accounts):
                item_checkbox = self.account_table.item(row, 0)
                if item_checkbox and item_checkbox.checkState() == Qt.Checked:
                    item_checkbox.setCheckState(Qt.Unchecked)
                    self.accounts[row]["selected"] = False
                    deselected_count += 1
                self.save_accounts()
        QMessageBox.information(self, "B·ªè ch·ªçn t√†i kho·∫£n", f"ƒê√£ b·ªè ch·ªçn {deselected_count} t√†i kho·∫£n ƒë∆∞·ª£c b√¥i ƒëen.")
        print(f"[DEBUG] ƒê√£ b·ªè ch·ªçn {deselected_count} t√†i kho·∫£n ƒë∆∞·ª£c b√¥i ƒëen.")
    
    def deselect_all_accounts(self):
        deselected_count = 0
        for row_idx in range(self.account_table.rowCount()):
            item = self.account_table.item(row_idx, 0)
            if item and item.checkState() == Qt.Checked:
                self.account_table.model().setData(item.index(), False, CheckboxDelegate.CheckboxStateRole)
                if row_idx < len(self.accounts):
                    self.accounts[row_idx]["selected"] = False
                deselected_count += 1
        self.save_accounts()
        QMessageBox.information(self, "B·ªè ch·ªçn t·∫•t c·∫£", f"ƒê√£ b·ªè ch·ªçn t·∫•t c·∫£ {deselected_count} t√†i kho·∫£n.")
        print(f"[DEBUG] ƒê√£ b·ªè ch·ªçn t·∫•t c·∫£ {deselected_count} t√†i kho·∫£n.")

    def add_selected_to_folder(self, folder_name):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", f"Th√™m v√†o th∆∞ m·ª•c \'{folder_name}\' ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print(f"[DEBUG] Ch·ª©c nƒÉng add_selected_to_folder ƒë∆∞·ª£c g·ªçi v·ªõi folder: {folder_name}")

    def remove_selected_from_folder(self, folder_name):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", f"X√≥a kh·ªèi th∆∞ m·ª•c \'{folder_name}\' ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print(f"[DEBUG] Ch·ª©c nƒÉng remove_selected_from_folder ƒë∆∞·ª£c g·ªçi v·ªõi folder: {folder_name}")

    def delete_selected_folder(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "X√≥a th∆∞ m·ª•c ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng delete_selected_folder ƒë∆∞·ª£c g·ªçi.")

    def set_account_status_selected(self, status):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", f"Chuy·ªÉn tr·∫°ng th√°i t√†i kho·∫£n v·ªÅ \'{status}\' ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print(f"[DEBUG] Ch·ª©c nƒÉng set_account_status_selected ƒë∆∞·ª£c g·ªçi v·ªõi status: {status}")

    def update_selected_proxy_info(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "C·∫≠p nh·∫≠t th√¥ng tin Proxy ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng update_selected_proxy_info ƒë∆∞·ª£c g·ªçi.")

    def open_selected_user_data_folder(self):
        QMessageBox.information(self, "Ch·ª©c nƒÉng", "M·ªü th∆∞ m·ª•c UserData ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn.")
        print("[DEBUG] Ch·ª©c nƒÉng open_selected_user_data_folder ƒë∆∞·ª£c g·ªçi.")

    def export_accounts(self):
        file_path, _ = QFileDialog.getSaveFileName(self, "Xu·∫•t t√†i kho·∫£n", "", "JSON Files (*.json)")
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(self.accounts, f, ensure_ascii=False, indent=4)
                QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ xu·∫•t t√†i kho·∫£n th√†nh c√¥ng!")
            except Exception as e:
                QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ xu·∫•t t√†i kho·∫£n: {str(e)}")

    def toggle_stealth_mode(self):
        self.stealth_mode_enabled = not self.stealth_mode_enabled
        status = "b·∫≠t" if self.stealth_mode_enabled else "t·∫Øt"
        QMessageBox.information(self, "Th√¥ng b√°o", f"ƒê√£ {status} ch·∫ø ƒë·ªô ·∫©n danh!")

    def delete_all_accounts(self):
        reply = QMessageBox.question(self, "X√°c nh·∫≠n", "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a t·∫•t c·∫£ t√†i kho·∫£n?",
                                   QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.accounts.clear()
            self.save_accounts()
            self.update_account_table()
            QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ x√≥a t·∫•t c·∫£ t√†i kho·∫£n!")
